1. ORM / JPA
   우리가 사용하는 대부분의 프로그램은 사용자가 입력한 데이터나 비지니스 로직 수행 결과로 얻은 데이터를 재사용할 수 있도록 데이터베이스에 저장을 함.
   하지만 자바의 객체와 데이터베이스의 테이블이 정확하게 일치하지는 않음. 따라서 둘 사이를 매핑하기 위해서 많은 SQL 구문과 자바 코드가 필요해짐.
   ORM은 이렇게 정확하게 일치하지 않는 자바 객체와 테이블 사이를 매핑해줌. 다시 말하면 ORM은 자바 객체에 저장된 데이터를 테이블의 Row 정보로 저장하고. 반대로 테이블에 저장된 Row 정보를 자바 객체로 매핑해줌.
   이 과정에서 사용되는 SQL 구문과 자바 코드을 ORM 프레임워크가 자동으로 만들어줌.
   지금까지 JDBC나 MyBatis를 이용해서 자바 객체와 테이블을 매핑.
   하지만 어떤 DB 연동 기술이나 프레임워크를 사용하더라도 SQL 명령어를 자바 클래스나 외부의 XML 파일에 작성해야 함.
   그리고 작성된 SQL은 유지보수 과정에서 지속적으로 수정되며 새로운 SQL이 추가되기도 함.
   ORM 프레임워크의 가장 큰 특징이자 장점은 DB 연동에 필요한 SQL을 자동으로 생성함.
   또한 이렇게 생성된 SQL DBMS가 변경될때 자동으로 변경이 됨.
   (다만 ORM 환경 설정 파일에서 DBMS가 변경된것을 알려주어야 함.)
1) ORM
   Object Relational Mapping의 줄임말로 객체 관계 매핑을 의미.
   자바와 같은 객체지향 언어에서 의미하는 객체와 RDB Relational Database 의 테이블을 자동으로 매핑하는 방법.
   클래스는 데이터베이스의 테이블과 매핑하기 위해 만들어진 것이 아니기 때문에 RDB 테이블과 어쩔 수 없는 불일치가 존재.
   ORM이 이 둘의 불일치와 제약사항을 해결하는 역할.
   ORM을 이용하면 쿼리문 작성이 아닌 코드(메서드)로 데이터를 조작할 수 있음.
2) JPA
   JPA Java Persistence API 는 자바 진영의 ORM 기술 표준으로 채택된 인터페이스 모음.
   ORM이 큰 개념이라면 JPA는 더 구체화된 스펙을 포함.
   즉 JPA 또한 실제로 동작하는 것이 아니고 어떻게 동작해야 하는지 매커니즘을 정리한 표준 명세.
   JPA를 구현한 대표적인 구현체로 Hibernate, EclipseLink, DataNucleus, OpenJpa 등이 있음.
   JPA 인터페이스를 구현한 가정 대표적인 오픈소스가 Hibernate이고 실질적인 기능은 하이버네이트에 구현되어 있음.
3. Spring Data JPA
   JPA를 편리하게 사용할 수 있도록 지원하는 스프링 하위 프로젝트 중 하나.
   CRUD 처리에 필요한 인터페이스를 제공하며, 하이버네이트의 엔티티 매니저를 직접 다루지 않고 리포지토리를 정의해
   사용함으로써 스프링에 적합한 쿼리를 동적으로 생성하는 방식으로 데이터베이스를 조작.
   이를 통해 하이버네이트에서 자주 사용되는 기능을 더 쉽게 사용할 수 있게 구현한 라이브러리.
3. JPA 사용 시 장점
   1) 특정 데이터베이스에 종속되지 않음.
      애플리케이션 개발을 위해 데이터베이스로 오라클 Oracle을 사용하여 개발을 진행했다고 가정을 하고, 만약 오라클을 MariaDB로 변경한다면 데이터베이스마다 쿼리문이 다르기 때문에 전체를 수정해야 함. 따라서 처음 선택한 데이터베이스를 변경하기 어려움.
      하지만 JPA는 추상화한 데이터 접근 계층을 재공함.
      설정 파일에 어떤 데이터베이스를 사용하는지 알려주면 얼마든지 데이터베이스를 변경할 수 있음.
   2) 객체지향적 프로그램
      JPA를 사용하면 데이터베이스 설계 중심의 패러다임에서 객체지향적으로 설계가 가능.
      이를 통해 좀 더 직관적이고 비지니스 로직에 집중할 수 있도록 도와줌.

2. JPA
JPA Java Persistence API 는 자바 진영의 ORM 기술 표준으로 채택된 인터페이스 모음.
ORM이 큰 개념이라면 JPA는 더 구체화된 스펙을 포함.
즉 JPA 또한 실제로 동작하는 것이 아니고 어떻게 동작해야 하는지 매커니즘을 정리한 표준 명세.
JPA를 구현한 대표적인 구현체로 Hibernate, EclipseLink, DataNucleus, OpenJpa 등이 있음.
JPA 인터페이스를 구현한 가정 대표적인 오픈소스가 Hibernate이고 실질적인 기능은 하이버네이트에 구현되어 있음.

3. Spring Data JPA
   JPA를 편리하게 사용할 수 있도록 지원하는 스프링 하위 프로젝트 중 하나.
   CRUD 처리에 필요한 인터페이스를 제공하며, 하이버네이트의 엔티티 매니저를 직접 다루지 않고 리포지토리를 정의해
   사용함으로써 스프링에 적합한 쿼리를 동적으로 생성하는 방식으로 데이터베이스를 조작.
   이를 통해 하이버네이트에서 자주 사용되는 기능을 더 쉽게 사용할 수 있게 구현한 라이브러리.

3. JPA 사용 시 장점
   1) 특정 데이터베이스에 종속되지 않음.
      애플리케이션 개발을 위해 데이터베이스로 오라클 Oracle을 사용하여 개발을 진행했다고 가정을 하고,
      만약 오라클을 MariaDB로 변경한다면 데이터베이스마다 쿼리문이 다르기 때문에 전체를 수정해야 함. 따라서 처음 선택한 데이터베이스를 변경하기 어려움.
      하지만 JPA는 추상화한 데이터 접근 계층을 재공함.
      설정 파일에 어떤 데이터베이스를 사용하는지 알려주면 얼마든지 데이터베이스를 변경할 수 있음.
   2) 객체지향적 프로그램
      JPA를 사용하면 데이터베이스 설계 중심의 패러다임에서 객체지향적으로 설계가 가능.
      이를 통해 좀 더 직관적이고 비지니스 로직에 집중할 수 있도록 도와줌.
   3) 생상성 향성
      데이터베이스 테이블에 새로운 컬럼이 추가 되었을 경우, 해당 테이블의 컬럼을 사용하는 DTO 클래스의 필드도 모두 변경해야 함. JPA에서는 테이블과 매핑된 클래스에 필드만 추가한다면 쉽게 관리가 가능.
      또한 SQL문을 직접 작성하지 않고 객체를 이용하여 동작하기 때문에 유지보수 측면에서 좋고 재사용성도 증가.

4. JPA 사용 시 단점
   1) 복잡한 쿼리 처리
      통계 처리 같은 복잡한 쿼리를 사용할 경우는 SQL문을 사용하는 것이 나을 수 있음.
      JPA에서는 Native SQL을 통해 기존의 SQL문을 사용할 수 있지만 그러면 특정 데이터베이스에 종속된다는 단점이 생김. 이를 보완하기 위해서 SQL과 유사한 기술인 JPQL, Querydsl을 지원.
   2) 성능 저하 위험
      객체 간의 매핑 설계가 잘못했을 때 성능 저하가 발생할 수 있으며,
      자동으로 생성되는 쿼리가 많기 때문에 개발자가 의도하지 않은 쿼리로 인해 성능이 저하되기도 함.
   3) 학습 시간
      JPA를 제대로 사용하려면 알아야 할 것이 많아서 학습하는데 시간이 오래 걸림.

5. 엔티티
   엔티티 Entity 란 데이터베이스의 테이블에 대응하는 클래스.
   @Entity가 붙은 클래스는 JPA에서 관리하며 엔티티라고 함.
   클래스 자체나 생성한 인스턴스도 엔티티라 부름.

6. 엔티티 매니저 팩토리
   엔티티 매니저 팩토리 Entity Manager Factory는 엔티티 매니저 인스턴스를 관리하는 주체.
   애플리케이션 실행 시 한 개만 만들어지며 사용자로 부터 요청이 오면 엔티티 매니저 팩토리로 부터 엔티티 매니저를 생성.

7. 엔티티 매니저
   엔티티 매니저 Entity Manager란 영속성 컨텍스르에 접근하여 앤티티에 대한 데이터베이스 작업을 제공.
   내부적으로 데이터베이스 커넥션을 사용해서 데이터베이스에 접근.

8. 영속성 컨텍스트
   JPA를 이해하기 위해서는 영속성 컨텍스트 Persistence Context를 이해하는 것이 가장 중요.
   엔티티를 영구 저장하는 환경으로 엔티티 매니저를 통해 영속성 컨텍스트에 접근.


2. Board OE|E| JpaRepository
   JPA를 이용하는 개발의 핵심은 객체지향을 통해서 영속 계층을 처리하는데 있음.
   따라서 JPA를 이용할 때는 테이블과 SQL을 다루는 것이 아니라 데이터에 해당하는 객체를 엔티티 객체하는 것으로 다루고 JPA로 이를 데이터베이스와 연동해서 관리.
   엔티티 객체는 쉽게 말해서 PK 기본키를 가지는 자바의 객체.
   엔티티 객체는 고유의 식별을 위해 @ld를 이용해서 객체를 구분하고 관리.
   Spring Data JPA는 엔티티 객체를 이용해서 JPA를 이용하는데 더욱 편리한 방법들을 제공하는 스프링 관련 라이브러리. Spring Data JPA는 자동으로 객체를 생성하고 이를 통해서 예외 처리 등을 자동으로 처리하는데 이를 위해서 제공되는 인터페이스가 JpaRepository.
   개발의 첫 단계은 엔티티 객체를 생성하기 위한 엔티티 클래스를 정의하는 것.
   엔티티 클래스는 반드시 @Entity가 존재하고 해당 엔티티 구분을 위한 @ld가 필요.
   프로젝트에 domain 패키지를 구성하고 게시물을 위한 Board 엔티티를 작성.

* 쿼리 메서드와 @Query
   쿼리 메서드는 보통 SQL에서 사용하는 키워드와 칼럼들을 같이 결합해서 구성하면 그 자체가 JPA에서 사용하는 쿼리가 되는 기능.
   일반적으로는 메서드 이름을 'findBY...' 혹은 'get...'으로 시작하고 칼럼명과 키워드를 결합하는 방식으로 구성.
   (각 키워드 사용법은 https://spring.io/projects/spring-data-jpa 참고)
   인텔리제이 얼티메이트에서는 자동완성 기능으로 쿼리 메서드를 작성할 수 있는 기능을 지원.
   쿼리 메서드는 상당히 매력적인 기능이지만 실제로 사용하려면 상당히 길고 복잡한 메서드를 작성하게 되는 경우가 많음. 예를 들어 '제목'에 특정한 '키워드'가 존재하는 게시글들을 bno의 역순으로 정렬해서 가져오고 싶다면 아래의 메소드 이름이 생성.
   Page<Board> findByTitleContainingOrderByBnoDesc(String keyword, Pageable pageable);
   쿼리 메서드는 주로 단순한 쿼리를 작성할 때 사용하고 실제 개발에서는 많이 사용되지 않음.
   쿼리 메서드와 유사하게 별도의 처리 없이 @Query로 JPQL을 이용할 수 있음.
   @Query 어노테이션의 value로 작성하는 문자열을 JPQL이라고 하는데
   JPQL은 SQL과 유사하게 JPA에서 사용하는 쿼리 언어 query language 라고 생각하면 됨.
   JPA는 데이터베이스에 독립적으로 개발이 가능하므로 특정한 데이터베이스에서만 동작하는 SQL 대신에 JPA에 맞게 사용하는 JPQL을 이용.
   JPQL은 테이블 대신에 엔티티 타입을 이용하고 칼럼 대신에 엔티티의 속성으로 이용해서 작성.
   JPQL SQL을 대신하는 용도로 사용하기 때문에 SQL에 존재하는 여러 키워드나 기능들이 거의 유사하게 제공.
   앞선 쿼리 메서드에 @Query를 이용한다면 다음과 같이 작성.
   @Query("select b form Board b where b.title like concat('%', :keyword, '%')")
   Page<Board> findKeyword(String keyword, Pageable pageable);
   작성된 JPQL을 보면 SQL과 상당히 유사하다는 것을 알 수 있음.
   @Query를 이용하면 크게 쿼리 메서드가 할 수 없는 몇 가지 기능을 할수 있음.
  @Query를 이용하면 크게 쿼리 메서드가 할 수 없는 몇 가지 기능을 할수 있음.
  '조인과 같이 복잡한 쿼리를 실행할 수 있는 기능

   원하는 속성들만 추출해서 Object[]로 처리하거나 DTO로 처리하는 기능.
   nativeQuery 속성값을 true로 지정해서 특정 데이터베이스에서 동작하는 SQL을 사용하는 기능.
  이중에서 native 속성을 지정하는 예제는 다음과 같이 작성 가능
  @Query(value="select now()", nativeQuery=true)
  String getTime();